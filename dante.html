<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dante's Digital Poetry</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            background: #0a0a0a;
            color: #d4af37;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            overflow: hidden;
        }

        #flame-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .poem-container {
            max-width: 800px;
            text-align: center;
            padding: 60px 40px;
            border: 2px solid #8b4513;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.85);
            box-shadow: 0 0 30px rgba(139, 0, 0, 0.3);
            position: relative;
            z-index: 10;
        }

        .poem-display {
            font-size: 28px;
            line-height: 1.8;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .poem-meta {
            font-size: 16px;
            color: #8b6914;
            font-style: italic;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(135deg, #8b0000, #ff6b35);
            color: #f5f5dc;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Crimson Text', serif;
            border: 2px solid #8b4513;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: linear-gradient(135deg, #ff6b35, #daa520);
            transform: translateY(-2px);
        }

        .status {
            font-size: 14px;
            color: #8b6914;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .poem-container {
                padding: 40px 20px;
            }
            
            .poem-display {
                font-size: 22px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <canvas id="flame-canvas"></canvas>
    <div class="poem-container">
        <div class="poem-meta" id="poem-meta">Loading poetry collection...</div>
        <div class="poem-display" id="poem-display">
            Welcome to Dante's Digital Poetry
        </div>
        <div class="controls">
            <button class="btn" onclick="showRandomPoem()">Random Poem</button>
            <button class="btn" onclick="toggleAutoplay()">Start Auto</button>
        </div>
        <div class="status" id="status">Ready</div>
    </div>

    <script>
        // Poetry collection and state
        let poetryCollection = null;
        let autoplayInterval = null;
        let isAutoplay = false;

        // Test data (replace with your actual JSON file)
        const testPoetryData = {
            "metadata": {
                "title": "Dante's Inferno AI Poetry Collection",
                "description": "500 short poems generated by GPT-2 trained on Dante's Inferno",
                "total_poems": 20
            },
            "poems": [
                {
                    "id": 1,
                    "prompt": "In the middle of",
                    "poem": "Life's journey I found myself in a dark wood.\nWhere the straight path had been lost.\nAh, how to describe what that wood was.\nSo wild and rough and dense with fear.\nThat death is little worse.",
                    "length": 5
                },
                {
                    "id": 2,
                    "prompt": "Through me the way",
                    "poem": "Into the woeful city, through me the way.\nTo eternal suffering, through me the way.\nAmong lost souls, justice moved my maker.\nDivine power made me, highest wisdom too.\nAnd primal love before me nothing.\nBut eternal things were made.",
                    "length": 6
                },
                {
                    "id": 3,
                    "prompt": "Abandon all hope",
                    "poem": "You who enter here, these words of darkest color.\nI perceived above a gate, and I said.\nMaster, their meaning fills me with dread.\nAnd he to me, as one experienced.\nHere you must leave behind all hesitation.",
                    "length": 5
                },
                {
                    "id": 4,
                    "prompt": "The path was dark",
                    "poem": "And treacherous, winding through shadows deep.\nThat seemed to whisper of forgotten sins.\nEach step echoed with the weight of choices.\nUnmade, and the air grew thick with sulfur.\nAnd the scent of ancient despair.",
                    "length": 5
                },
                {
                    "id": 5,
                    "prompt": "I found myself in",
                    "poem": "A valley deep and savage, where reason seemed.\nTo have no power over the wild beasts.\nThe leopard with its spotted hide appeared.\nThe lion with its head held high in pride.\nAnd the she-wolf lean with endless hunger.\nThat made many lives miserable.",
                    "length": 6
                },
                {
                    "id": 6,
                    "prompt": "Beyond the gates",
                    "poem": "Of that infernal city, where hope abandons.\nAll who enter there, the very air.\nTrembled with the weight of eternal punishment.\nHere justice reigns supreme and mercy.\nFinds no voice among the damned.",
                    "length": 5
                },
                {
                    "id": 7,
                    "prompt": "Here sighs",
                    "poem": "Complaints, and ululations loud resounded.\nThrough the air devoid of stars, so that.\nAt first I wept to hear such sounds.\nDiverse languages, horrible pronunciations.\nWords of pain, accents of anger.",
                    "length": 5
                },
                {
                    "id": 8,
                    "prompt": "The divine power",
                    "poem": "Made me, highest wisdom too, and primal love.\nCreated every soul that dwells within.\nThese circles of despair and suffering.\nBefore me nothing but eternal things.\nWere made, and I endure as long.\nAs time itself shall last forever.",
                    "length": 6
                },
                {
                    "id": 9,
                    "prompt": "O you who enter",
                    "poem": "Here, abandon every hope of return.\nTo the world above, for here begins.\nThe path of no return, where suffering.\nKnows no end and time stands still.\nIn endless repetition of divine justice.",
                    "length": 5
                },
                {
                    "id": 10,
                    "prompt": "Justice moved",
                    "poem": "My architect to raise these walls where sinners.\nFind their proper place according to crimes.\nHere divine love and highest wisdom work.\nIn perfect harmony to maintain the order.\nOf the universe and eternal law.",
                    "length": 5
                },
                {
                    "id": 11,
                    "prompt": "When I had journeyed",
                    "poem": "Half of our life's way, I came upon.\nA place where the sun was silent.\nAnd found that I had lost the path.\nThat does not stray from righteousness.\nAh, how hard it is to tell.",
                    "length": 5
                },
                {
                    "id": 12,
                    "prompt": "Midway upon",
                    "poem": "The journey of our life I found myself.\nWithin a forest dark, for the straightforward.\nPath had been lost, and it is hard.\nTo tell what kind of wood that was.\nSo savage, dense and harsh.",
                    "length": 5
                },
                {
                    "id": 13,
                    "prompt": "Before me nothing",
                    "poem": "But eternal things were made, and I endure.\nEternally, abandon all hope, you who enter.\nHere these words I saw inscribed.\nIn darkest color over a portal.\nAnd I said, Master, their sense is hard.",
                    "length": 5
                },
                {
                    "id": 14,
                    "prompt": "I am the way",
                    "poem": "Into the city of woe, I am the way.\nTo a forsaken people, I am the way.\nInto eternal sorrow, sacred justice.\nMoved my architect, divine power made me.\nHighest wisdom too, and primal love.",
                    "length": 5
                },
                {
                    "id": 15,
                    "prompt": "Sacred justice",
                    "poem": "Moved my supreme maker, divine power.\nMade me, and highest wisdom too.\nAnd primal love created every soul.\nBefore me nothing but eternal things.\nWere made, and I endure eternally.",
                    "length": 5
                },
                {
                    "id": 16,
                    "prompt": "Primal love",
                    "poem": "Created all that dwells within these circles.\nOf endless punishment and divine retribution.\nWhere sinners find their place according.\nTo the nature of their earthly crimes.\nAnd justice reigns without mercy's touch.",
                    "length": 5
                },
                {
                    "id": 17,
                    "prompt": "The darksome air",
                    "poem": "Trembled with sighs and lamentations.\nThat rose from countless souls who suffered.\nWithout hope of death, various languages.\nHorrible pronunciations, words of pain.\nMade a tumult in that timeless black.",
                    "length": 5
                },
                {
                    "id": 18,
                    "prompt": "Various languages",
                    "poem": "Horrible pronunciations, words of pain.\nAccents of anger, voices high and hoarse.\nAnd sounds of striking hands made a tumult.\nThat continues without end in that air.\nOf timeless black, like sand when whirlwinds.",
                    "length": 5
                },
                {
                    "id": 19,
                    "prompt": "Words of pain",
                    "poem": "Accents of anger echoed through the void.\nVoices high and hoarse created tumult.\nThat never ceases in that place where light.\nHas been forever banished from the realm.\nAnd hope lies buried beneath despair.",
                    "length": 5
                },
                {
                    "id": 20,
                    "prompt": "Accents of anger",
                    "poem": "Voices raised in endless lamentation.\nHigh and hoarse they cry without relief.\nIn that place where time has lost all meaning.\nAnd suffering knows no bounds or limits.\nWhere souls are trapped in their own making.",
                    "length": 5
                }
            ]
        };

        // Flame particle system
        let canvas, ctx;
        let particles = [];
        let flameSources = [];

        class FlameParticle {
            constructor(x, y, intensity = 1) {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.8;
                this.vy = -Math.random() * 3 * intensity - 1;
                this.life = Math.random() * 120 + 80;
                this.maxLife = this.life;
                this.baseSize = Math.random() * 8 + 4;
                this.width = this.baseSize;
                this.height = this.baseSize * (1.5 + Math.random() * 2);
                this.colorType = Math.random();
                this.flicker = Math.random() * 0.4 + 0.6;
                this.swayPhase = Math.random() * Math.PI * 2;
                this.swaySpeed = Math.random() * 0.05 + 0.02;
            }

            update() {
                // Flame sway motion
                this.swayPhase += this.swaySpeed;
                this.vx += Math.sin(this.swayPhase) * 0.02;
                
                this.x += this.vx;
                this.y += this.vy;
                
                // Flames rise and dissipate
                this.vy *= 0.98;
                this.vx *= 0.995;
                this.life -= 1;
                
                // Size changes as flame rises
                const lifeRatio = this.life / this.maxLife;
                this.width = this.baseSize * lifeRatio * this.flicker;
                this.height = this.baseSize * (1.5 + Math.random() * 2) * lifeRatio;
                
                // Flickering effect
                this.flicker += (Math.random() - 0.5) * 0.15;
                this.flicker = Math.max(0.3, Math.min(1.2, this.flicker));
            }

            draw() {
                if (this.life <= 0) return;
                
                const lifeRatio = this.life / this.maxLife;
                const alpha = lifeRatio * this.flicker * 0.3;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Create flame-like gradient
                const gradient = ctx.createRadialGradient(
                    this.x, this.y + this.height * 0.3, 0,
                    this.x, this.y, this.height
                );
                
                if (this.colorType < 0.2) {
                    // Deep red/orange at base
                    gradient.addColorStop(0, '#ff2d00');
                    gradient.addColorStop(0.4, '#ff6600');
                    gradient.addColorStop(1, '#ff9900');
                } else if (this.colorType < 0.6) {
                    // Orange flames
                    gradient.addColorStop(0, '#ff4400');
                    gradient.addColorStop(0.4, '#ff8800');
                    gradient.addColorStop(1, '#ffaa00');
                } else {
                    // Yellow/white hot flames
                    gradient.addColorStop(0, '#ff6600');
                    gradient.addColorStop(0.4, '#ffaa00');
                    gradient.addColorStop(1, '#ffdd44');
                }
                
                // Draw flame shape
                ctx.fillStyle = gradient;
                ctx.beginPath();
                
                // Create teardrop/flame shape
                const bottomWidth = this.width;
                const topWidth = this.width * 0.3;
                
                ctx.ellipse(this.x, this.y, bottomWidth, this.height * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Add flame tip
                ctx.beginPath();
                ctx.moveTo(this.x - topWidth, this.y - this.height * 0.3);
                ctx.quadraticCurveTo(this.x, this.y - this.height, this.x + topWidth, this.y - this.height * 0.3);
                ctx.quadraticCurveTo(this.x, this.y - this.height * 0.5, this.x - topWidth, this.y - this.height * 0.3);
                ctx.fill();
                
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        class FlameSource {
            constructor(x, y, intensity = 1) {
                this.x = x;
                this.y = y;
                this.intensity = intensity;
                this.phase = Math.random() * Math.PI * 2;
                this.flickerSpeed = Math.random() * 0.02 + 0.01;
            }

            update() {
                this.phase += this.flickerSpeed;
                
                // Gentle movement
                this.x += Math.sin(this.phase) * 0.3;
                this.y += Math.cos(this.phase * 0.7) * 0.1;
            }

            emit() {
                if (Math.random() < 0.6) { // Higher emission rate for more flames
                    particles.push(new FlameParticle(this.x, this.y, this.intensity));
                }
            }
        }

        function initFlameSystem() {
            canvas = document.getElementById('flame-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            
            // Create flame sources along the bottom of the screen
            const numSources = 8;
            const spacing = canvas.width / (numSources + 1);
            
            for (let i = 0; i < numSources; i++) {
                flameSources.push(new FlameSource(
                    spacing * (i + 1) + (Math.random() - 0.5) * 100,
                    canvas.height - 20 + Math.random() * 40,
                    Math.random() * 0.7 + 0.8
                ));
            }
            
            // Add a few random sources for variety
            for (let i = 0; i < 4; i++) {
                flameSources.push(new FlameSource(
                    Math.random() * canvas.width,
                    canvas.height - 10 + Math.random() * 30,
                    Math.random() * 0.5 + 0.3
                ));
            }
            
            console.log('Flame system initialized');
        }

        function resizeCanvas() {
            if (!canvas) return;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function updateFlames() {
            if (!ctx) return;
            
            // Clear canvas with a very subtle fade effect
            ctx.fillStyle = 'rgba(8, 6, 4, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update flame sources
            flameSources.forEach(source => {
                source.update();
                source.emit();
                
                // Keep sources along the bottom edge
                if (source.x < -100) source.x = canvas.width + 100;
                if (source.x > canvas.width + 100) source.x = -100;
                
                // Ensure flames stay at bottom
                if (source.y < canvas.height - 100) {
                    source.y = canvas.height - 20 + Math.random() * 40;
                }
                if (source.y > canvas.height + 50) {
                    source.y = canvas.height - 10;
                }
            });
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }
        }

        function startFlameAnimation() {
            function animate() {
                updateFlames();
                requestAnimationFrame(animate);
            }
            animate();
        }

        // Window resize handler
        window.addEventListener('resize', resizeCanvas);
        async function loadPoetryCollection() {
            try {
                
                const response = await fetch('dante_poetry_collection.json');
                if (!response.ok) {
                    throw new Error('Failed to load poetry collection');
                }
                poetryCollection = await response.json();
              
                updateStatus(`Loaded ${poetryCollection.poems.length} poems`);
                console.log('Poetry collection loaded:', poetryCollection.metadata);
                return true;
                
            } catch (error) {
                console.error('Error loading poetry:', error);
                updateStatus('Error loading poetry collection');
                return false;
            }
        }

        // Get random poem
        function getRandomPoem() {
            if (!poetryCollection || !poetryCollection.poems) {
                return null;
            }
            
            const randomIndex = Math.floor(Math.random() * poetryCollection.poems.length);
            return poetryCollection.poems[randomIndex];
        }

        // Display poem
        function displayPoem(poem) {
            if (!poem) return;
            
            const poemDisplay = document.getElementById('poem-display');
            const poemMeta = document.getElementById('poem-meta');
            
            // Combine prompt and poem content
            const fullPoem = poem.prompt + ' ' + poem.poem;
            poemDisplay.innerHTML = fullPoem.replace(/\n/g, '<br>');
            
            // Update metadata to show only poem number
            poemMeta.textContent = `Poem ${poem.id}`;
            
            console.log(`Displaying poem ${poem.id}: "${poem.prompt}"`);
        }

        // Show random poem
        function showRandomPoem() {
            const poem = getRandomPoem();
            if (poem) {
                displayPoem(poem);
                updateStatus('Random poem displayed');
            } else {
                updateStatus('No poems available');
            }
        }

        // Toggle autoplay
        function toggleAutoplay() {
            const btn = event.target;
            
            if (isAutoplay) {
                // Stop autoplay
                clearInterval(autoplayInterval);
                autoplayInterval = null;
                isAutoplay = false;
                btn.textContent = 'Start Auto';
                updateStatus('Autoplay stopped');
            } else {
                // Start autoplay
                isAutoplay = true;
                btn.textContent = 'Stop Auto';
                updateStatus('Autoplay started');
                
                // Show first poem immediately
                showRandomPoem();
                
                // Then show new poem every 5 seconds
                autoplayInterval = setInterval(() => {
                    showRandomPoem();
                }, 5000);
            }
        }

        // Update status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing poetry display with flame background...');
            
            // Initialize flame system first
            initFlameSystem();
            startFlameAnimation();
            
            updateStatus('Loading...');
            
            const loaded = await loadPoetryCollection();
            
            if (loaded) {
                updateStatus('Ready - Click "Random Poem" to begin');
                // Show first poem
                showRandomPoem();
            } else {
                updateStatus('Failed to load poetry collection');
            }
        });
    </script>
</body>
</html>